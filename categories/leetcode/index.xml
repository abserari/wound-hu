<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Wound</title>
    <link>/categories/leetcode/</link>
    <description>Recent content in leetcode on Wound</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Dec 2018 12:40:07 +0800</lastBuildDate>
    
	<atom:link href="/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两数之和</title>
      <link>/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 08 Dec 2018 12:40:07 +0800</pubDate>
      
      <guid>/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description> 问题描述 给定一个整数数列，找出其中和为特定值的那两个数。
你可以假设每个输入都只会有一种答案，同样的元素不能被重用。
示例 1 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  思路 1.遍历每个元素 x，并查找是否存在一个值与 target−x相等的目标元素。 2.在进行迭代并将元素插入到表中的同时，检查表中是否已经存在当前元素所对应的目标元素。如果它存在立即将其返回
实现 暴力法 哈希法 func twoSum(nums []int, target int) []int { m := make(map[int]int) for i := 0; i &amp;lt; len(nums); i++ { another := target - nums[i] if _, ok := m[another]; ok { return []int{m[another], i} } m[nums[i]] = i } return nil }  </description>
    </item>
    
    <item>
      <title>设计链表</title>
      <link>/blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 07 Dec 2018 11:21:45 +0800</pubDate>
      
      <guid>/blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>问题描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
 get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。  示例 MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3 linkedList.get(1); //返回3  提示  所有值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。  思路 实现很简单，ac有很多坑</description>
    </item>
    
    <item>
      <title>回文数</title>
      <link>/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>问题描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1 输入: 121 输出: true  示例 2 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。  示例 3 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。  进阶:
你能不将整数转为字符串来解决这个问题吗？
思路 将数字一半反转，然后将反转后的数字与原始数字另一半进行比较，如果它们是相同的，那么这个数字就是回文。  例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较即可。 负数不是回文。
实现 func isPalindrome(x int) bool { if x &amp;lt; 0 { return false } if (x &amp;lt; 10) { return true } p, k := 0, x for k!</description>
    </item>
    
  </channel>
</rss>