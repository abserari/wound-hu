<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode-hard on Wound</title>
    <link>/categories/leetcode-hard/</link>
    <description>Recent content in leetcode-hard on Wound</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 09 Dec 2018 17:07:54 +0800</lastBuildDate>
    
	<atom:link href="/categories/leetcode-hard/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两个排序数组的中位数</title>
      <link>/blog/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sun, 09 Dec 2018 17:07:54 +0800</pubDate>
      
      <guid>/blog/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>问题描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。
请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
你可以假设 nums1 和 nums2 不同时为空。
示例 1 nums1 = [1, 3] nums2 = [2] 中位数是 2.0  示例 2 nums1 = [1, 2] nums2 = [3, 4] 中位数是 (2 + 3)/2 = 2.5  思路 给出两个有序数组，假设两个数组的长度和是 len，如果 len 为奇数，那么我们求的就是两个数组合并后的第 (len &amp;gt;&amp;gt; 1) + 1 大的数，如果 len 为偶数，就是第 (len &amp;gt;&amp;gt; 1) 和 (len &amp;gt;&amp;gt; 1) + 1 两个数的平均数。</description>
    </item>
    
    <item>
      <title>最长有效括号</title>
      <link>/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sun, 09 Dec 2018 17:07:24 +0800</pubDate>
      
      <guid>/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>问题描述 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1 输入: &amp;quot;(()&amp;quot; 输出: 2 解释: 最长有效括号子串为 &amp;quot;()&amp;quot;  示例 2 输入: &amp;quot;)()())&amp;quot; 输出: 4 解释: 最长有效括号子串为 &amp;quot;()()&amp;quot;  思路 遍历 1.record 记录每个符号的状态，如果能够和前面的配上对，就记录为2，否则，记录为0
输入：) ( ( ) ( ) ) ) ( ( ( ( ( ) ) ) ) ( 记录：0 0 0 2 0 2 2 0 0 0 0 0 0 2 2 2 2 0 检查：0 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0  2.</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sun, 09 Dec 2018 17:06:43 +0800</pubDate>
      
      <guid>/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>问题描述 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。
&#39;.&#39; 匹配任意单个字符。 &#39;*&#39; 匹配零个或多个前面的元素。  匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
说明  s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。  示例 1 输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; 输出: false 解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。  示例 2 输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; 输出: true 解释: &#39;*&#39; 代表可匹配零个或多个前面的元素, 即可以匹配 &#39;a&#39; 。因此, 重复 &#39;a&#39; 一次, 字符串可变为 &amp;quot;aa&amp;quot;。  示例 3 输入: s = &amp;quot;ab&amp;quot; p = &amp;quot;.</description>
    </item>
    
  </channel>
</rss>