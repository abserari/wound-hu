<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Wound</title>
    <link>/blog/</link>
    <description>Recent content in Blog on Wound</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 09 Dec 2018 17:07:54 +0800</lastBuildDate>
    
	<atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两个排序数组的中位数</title>
      <link>/blog/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sun, 09 Dec 2018 17:07:54 +0800</pubDate>
      
      <guid>/blog/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>问题描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。
请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
你可以假设 nums1 和 nums2 不同时为空。
示例 1 nums1 = [1, 3] nums2 = [2] 中位数是 2.0  示例 2 nums1 = [1, 2] nums2 = [3, 4] 中位数是 (2 + 3)/2 = 2.5  思路 给出两个有序数组，假设两个数组的长度和是 len，如果 len 为奇数，那么我们求的就是两个数组合并后的第 (len &amp;gt;&amp;gt; 1) + 1 大的数，如果 len 为偶数，就是第 (len &amp;gt;&amp;gt; 1) 和 (len &amp;gt;&amp;gt; 1) + 1 两个数的平均数。</description>
    </item>
    
    <item>
      <title>最长有效括号</title>
      <link>/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sun, 09 Dec 2018 17:07:24 +0800</pubDate>
      
      <guid>/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>问题描述 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。
示例 1 输入: &amp;quot;(()&amp;quot; 输出: 2 解释: 最长有效括号子串为 &amp;quot;()&amp;quot;  示例 2 输入: &amp;quot;)()())&amp;quot; 输出: 4 解释: 最长有效括号子串为 &amp;quot;()()&amp;quot;  思路 遍历 1.record 记录每个符号的状态，如果能够和前面的配上对，就记录为2，否则，记录为0
输入：) ( ( ) ( ) ) ) ( ( ( ( ( ) ) ) ) ( 记录：0 0 0 2 0 2 2 0 0 0 0 0 0 2 2 2 2 0 检查：0 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0  2.</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sun, 09 Dec 2018 17:06:43 +0800</pubDate>
      
      <guid>/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>问题描述 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。
&#39;.&#39; 匹配任意单个字符。 &#39;*&#39; 匹配零个或多个前面的元素。  匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
说明  s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。  示例 1 输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; 输出: false 解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。  示例 2 输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; 输出: true 解释: &#39;*&#39; 代表可匹配零个或多个前面的元素, 即可以匹配 &#39;a&#39; 。因此, 重复 &#39;a&#39; 一次, 字符串可变为 &amp;quot;aa&amp;quot;。  示例 3 输入: s = &amp;quot;ab&amp;quot; p = &amp;quot;.</description>
    </item>
    
    <item>
      <title>字符串的排列</title>
      <link>/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Sun, 09 Dec 2018 17:06:03 +0800</pubDate>
      
      <guid>/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description> 问题描述 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。
示例1 输入: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; 输出: True 解释: s2 包含 s1 的排列之一 (&amp;quot;ba&amp;quot;).  示例2 输入: s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; 输出: False  注意：
 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间  思路 滑动窗口 实现 func checkInclusion(s1 string, s2 string) bool { n1 := len(s1) n2 := len(s2) if n1 &amp;gt; n2 { return false } h1 := 0 h2 := 0 for i := 0; i &amp;lt; n1; i++ { c1 := s1[i] - &#39;a&#39; c2 := s2[i] - &#39;a&#39; h1 += 1 &amp;lt;&amp;lt; c1 h2 += 1 &amp;lt;&amp;lt; c2 } if h1 == h2 { return true } for i := n1; i &amp;lt; n2; i++ { cb := s2[i-n1] - &#39;a&#39; ce := s2[i] - &#39;a&#39; h2 += (1 &amp;lt;&amp;lt; ce) - (1 &amp;lt;&amp;lt; cb) if h1 == h2 { return true } } return false }  </description>
    </item>
    
    <item>
      <title>两数相加</title>
      <link>/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sun, 09 Dec 2018 17:05:31 +0800</pubDate>
      
      <guid>/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>问题描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出：7 -&amp;gt; 0 -&amp;gt; 8 原因：342 + 465 = 807  思路 我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。
图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。
请特别注意以下情况      测试用例  说明    l1=[0,1]l1=[0,1] l2=[0,1,2]l2=[0,1,2]   当一个列表比另一个列表长时。    l1=[]l1=[] l2=[0,1]l2=[0,1]   当一个列表为空时，即出现空列表。    l1=[9,9]l1=[9,9] l2=[1]l2=[1]   求和运算最后可能出现额外的进位，这一点很容易被遗忘      实现 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { resPre := &amp;amp;ListNode{} cur := resPre carry := 0 for l1 !</description>
    </item>
    
    <item>
      <title>盛最多水的容器</title>
      <link>/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 09 Dec 2018 17:04:59 +0800</pubDate>
      
      <guid>/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description> 问题描述 给定 *n* 个非负整数 a~1~，a~2，~&amp;hellip;，a~n，~每个数代表坐标中的一个点 (i, ai) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 *n* 的值至少为 2。
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 1 输入: [1,8,6,2,5,4,8,3,7] 输出: 49  思路 遍历 直接遍历每对可能出现的线段组合并找出这些情况之下的最大面积。
双指针 两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。 在线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxArea来持续存储到目前为止所获得的最大面积。 找出指针所指向的两条线段形成的区域，更新 maxArea，并将指向较短线段的指针向较长线段那端移动一步。
实现 遍历 func maxArea(height []int) int { var maxArea int var curArea int for i := 0; i &amp;lt; len(height)-1; i++ { for j := 0; j &amp;lt; len(height); j++ { if height[i]&amp;gt;height[j] { curArea = (j-i)*height[j] }else { curArea = (j-i)*height[i] } if curArea &amp;gt; maxArea { maxArea = curArea } } } return maxArea }  双指针 func maxArea(height []int) int { maxArea := 0 for i, j := 0, len(height)-1; i &amp;lt; j; { if height[i] &amp;lt;= height[j] { curArea := height[i] * (j - i) if curArea &amp;gt; maxArea { maxArea = curArea } i++ } else { curArea := height[j] * (j - i) if curArea &amp;gt; maxArea { maxArea = curArea } j-- } } return area }  </description>
    </item>
    
    <item>
      <title>旋转图像</title>
      <link>/blog/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Sun, 09 Dec 2018 17:04:02 +0800</pubDate>
      
      <guid>/blog/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
      <description>问题描述 给定一个 *n *× *n* 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
示例 1 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ]  示例 2 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]  思路 分治法（可能） 该题意，可以把一个四边形框四个角上的元素逐个交换，顺序调整框的大小和位置，进行操作
数学法（？） 可以看出，旋转90度实际上是将矩阵先转置，然后进行列的交换</description>
    </item>
    
    <item>
      <title>无重复字符的最长字串</title>
      <link>/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</link>
      <pubDate>Sun, 09 Dec 2018 17:03:34 +0800</pubDate>
      
      <guid>/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</guid>
      <description>问题描述 给定一个字符串，找出不含有重复字符的最长子串的长度。
示例 1 输入: &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 无重复字符的最长子串是 &amp;quot;abc&amp;quot;，其长度为 3。  示例 2 输入: &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 无重复字符的最长子串是 &amp;quot;b&amp;quot;，其长度为 1。  示例 3 输入: &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 无重复字符的最长子串是 &amp;quot;wke&amp;quot;，其长度为 3。 请注意，答案必须是一个子串，&amp;quot;pwke&amp;quot; 是一个子序列 而不是子串。  思路 滑动窗口 使用 整数数组用asc2码表示字符 将字符存储在当前窗口 [i,j)（最初 j=i）中。 滑动索引 j，如果它不在 整数数组标记中，继续滑动 j 向后查找 如果 s[j]在 [i,j)范围内有与 j′重复的字符， 直接跳过 [i，j′]范围内的所有元素，并将 i变为 j′+1。
实现 滑动窗口 func lengthOfLongestSubstring(s string) int { length := len(s) num := 0 ascii := [128]int{} i := 0 for j := 0; j &amp;lt; length; j++ { tmp := ascii[s[j]] if tmp &amp;gt; i { i = tmp } tmp = j - i + 1 if tmp &amp;gt; num { num = tmp } ascii[s[j]] = j + 1 } return num }  滑动二 func lengthOfLongestSubstring(s string) int { // location[s[i]] == j 表示： // s中第i个字符串，上次出现在s的j位置，所以，在s[j+1:i]中没有s[i] // location[s[i]] == -1 表示： s[i] 在s中第一次出现 location := [256]int{} // 只有256长是因为，假定输入的字符串只有ASCII字符 for i := range location { location[i] = -1 // 先设置所有的字符都没有见过 } maxLen, left := 0, 0 for i := 0; i &amp;lt; len(s); i++ { // 说明s[i]已经在s[left:i+1]中重复了 // 并且s[i]上次出现的位置在location[s[i]] if location[s[i]] &amp;gt;= left { left = location[s[i]] + 1 // 在s[left:i+1]中去除s[i]字符及其之前的部分 } else if i+1-left &amp;gt; maxLen { // fmt.</description>
    </item>
    
    <item>
      <title>删除链表中的倒数第N个节点</title>
      <link>/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 09 Dec 2018 17:02:34 +0800</pubDate>
      
      <guid>/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>问题描述 给定一个链表，删除链表的倒数第 *n *个节点，并且返回链表的头结点。
示例 1 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.  说明 给定的 *n* 保证是有效的。
进阶 你能尝试使用一趟扫描实现吗？
思路 一趟扫描，通过使用两个相距定长 n 的指针，同时向后移动，当后面的指针指到链表的尾部的时候，该指针正好指向需要删除的倒数第 n 个节点
实现 Go 版本 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { p := &amp;amp;ListNode{Val: 0, Next: head} q := p qhead := q for i := 0; i &amp;lt; n; i++ { p = p.</description>
    </item>
    
    <item>
      <title>岛屿的个数</title>
      <link>/blog/%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 09 Dec 2018 17:01:51 +0800</pubDate>
      
      <guid>/blog/%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description> 问题描述 给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
示例 1 输入: 11110 11010 11000 00000 输出: 1  示例 2 输入: 11000 11000 00100 00011 输出: 3  思路 遍历每一个网格，如果存在，则以此为起点，向4个方向扩张，如果是岛屿&amp;rsquo;1&amp;rsquo;就置为&amp;rsquo;0&amp;rsquo;，表示这个岛屿是刚才的岛屿的一部分。最后返回 island 的个数
实现 Go 版本 func numIslands(grid [][]byte) int { islands := 0 for i,_ := range grid { for j,_ := range grid[i]{ if grid[i][j] == &#39;1&#39; { islands++ expandIsland(grid, i, j) } } } return islands } func expandIsland(grid [][]byte, m int, n int){ if m &amp;gt;= 0 &amp;amp;&amp;amp; m &amp;lt; len(grid) &amp;amp;&amp;amp; n &amp;gt;= 0 &amp;amp;&amp;amp; n &amp;lt; len(grid[m]) &amp;amp;&amp;amp; grid[m][n] == &#39;1&#39; { grid[m][n] = &#39;0&#39; expandIsland(grid, m-1, n) expandIsland(grid, m+1, n) expandIsland(grid, m, n-1) expandIsland(grid, m, n+1) } }  </description>
    </item>
    
    <item>
      <title>环形数组循环</title>
      <link>/blog/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 09 Dec 2018 17:01:20 +0800</pubDate>
      
      <guid>/blog/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF/</guid>
      <description>问题描述 给定一组含有正整数和负整数的数组。如果某个索引中的 n 是正数的，则向前移动 n 个索引。相反，如果是负数(-n)，则向后移动 n 个索引。
假设数组首尾相接。判断数组中是否有环。环中至少包含 2 个元素。环中的元素一律“向前”或者一律“向后”。
注意：给定数组保证不包含元素&amp;rdquo;0&amp;rdquo;。
示例 1 给定数组[-1, 2], 没有循环。  示例 2 给定数组 [2, -1, 1, 2, 2], 有一个循环，从索引 0 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 0。  思路 这里的循环必须是只向前或者只向后形成循环，即一个循环中，都是正数或者负数。 根据坐标建立一对一的映射，一旦某个达到的坐标已经有映射了，说明环存在。 建立一个 v 数组，来记录访问过的数字，然后遍历原数组，如果当前数字已经访问过了，直接跳过，否则就以当前位置坐标为起始点开始查找 将当前位置在 v 数组中标记 true ，然后查找当前位置坐标加上对应的数字的新索引，由于是循环数组，所以结果可能会超出数组的长度，所以要对数组长度取余。（数字可能是负数，补上一个n，使其变为正数） 检查：如果 next 和 cur 相等，说明此时是一个数字的循环，弃掉 如果一个循环中不全是负数或正数，也要弃掉
实现 Go 版本 func circularArrayLoop(nums []int) bool { m := make(map[int]int) n := len(nums) v := make([]bool, n) for i := 0; i &amp;lt; n; i++ { if v[i] { continue } cur := i for { v[cur] = true next := (cur + nums[cur]) % n if next &amp;lt; 0 { next += n } if next == cur || nums[next]*nums[cur] &amp;lt; 0 { break } if m[next] !</description>
    </item>
    
    <item>
      <title>搜索旋转排序数组</title>
      <link>/blog/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 09 Dec 2018 17:00:36 +0800</pubDate>
      
      <guid>/blog/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description> 问题描述 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
示例 1 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4  示例 2 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1  思路 二分
实现 二分法 func search(nums []int, target int) int { left, right := 0, len(nums) - 1 for left &amp;lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } // 左边部分数组递增 if nums[mid] &amp;gt;= nums[left] { // target在递增数组中 if nums[left] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt; nums[mid] { right = mid - 1 } else { left = mid + 1 } } else { if nums[mid] &amp;lt; target &amp;amp;&amp;amp; target &amp;lt;= nums[right] { left = mid + 1 } else { right = mid - 1 } } } return -1 }  </description>
    </item>
    
    <item>
      <title>打家劫舍II</title>
      <link>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii/</link>
      <pubDate>Sun, 09 Dec 2018 16:58:37 +0800</pubDate>
      
      <guid>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii/</guid>
      <description> 问题描述 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
示例 1 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。  示例 2 输入: [1,2,3,1] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。  思路 分两种情况讨论，数组第一个偷的情况和第一个不偷的情况
实现 方法一 func rob(nums []int) int { switch size { case 0: return 0 case 1: return nums[0] } m := make([]int, 2) m[0] = nums[0] m[1] = max(nums[0], nums[1]) for i := 2; i &amp;lt; len(nums)-1; i++ { m = append(m, max(m[i-1], m[i-2]+nums[i])) } n := make([]int, 2) nums[0] = 0 n[0] = nums[0] n[1] = max(nums[1], nums[0]) for j := 2; j &amp;lt; len(nums); j++ { n = append(n, max(n[j-1], n[j-2]+nums[j])) } return max(m[len(nums)-2], n[len(nums)-1]) } func max(a, b int) int { if a &amp;gt; b { return a } return b }  </description>
    </item>
    
    <item>
      <title>打家劫舍III</title>
      <link>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii/</link>
      <pubDate>Sun, 09 Dec 2018 16:58:30 +0800</pubDate>
      
      <guid>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii/</guid>
      <description>问题描述 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
示例 1 输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.  示例 2 输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.  思路 回溯 每一个根节点讨论是否选与不选，比较左右孩子节点值之和 和 没有左右孩子节点之和，选取大的计入 这种方法重复计算了很多地方，比如要完成一个节点的计算，就得一直找左右子节点计算，消耗时间过多
所以使用一个 map 存储已经算过的节点
实现 回溯 func rob(root *TreeNode) int { m := make(map[*TreeNode]int) return dfs(root, m) } func dfs(root *TreeNode, m map[*TreeNode]int) int { if root == nil { return 0 } if m[root] !</description>
    </item>
    
    <item>
      <title>移动K位数字</title>
      <link>/blog/%E7%A7%BB%E5%8A%A8k%E4%BD%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sun, 09 Dec 2018 16:57:36 +0800</pubDate>
      
      <guid>/blog/%E7%A7%BB%E5%8A%A8k%E4%BD%8D%E6%95%B0%E5%AD%97/</guid>
      <description>问题描述 给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k *位数字，使得剩下的数字最小。
注意:
 *num* 的长度小于 10002 且 ≥ k。 *num* 不会包含任何前导零。  __示例 1 __ 输入: num = &amp;quot;1432219&amp;quot;, k = 3 输出: &amp;quot;1219&amp;quot; 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  __示例 2 __ 输入: num = &amp;quot;10200&amp;quot;, k = 1 输出: &amp;quot;200&amp;quot; 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  示例__ 3 __ 输入: num = &amp;quot;10&amp;quot;, k = 2 输出: &amp;quot;0&amp;quot; 解释: 从原数字移除所有的数字，剩余为空就是0。  思路 贪心</description>
    </item>
    
    <item>
      <title>Pow(x,n)</title>
      <link>/blog/pow/</link>
      <pubDate>Sun, 09 Dec 2018 16:56:56 +0800</pubDate>
      
      <guid>/blog/pow/</guid>
      <description>问题描述 给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。  示例 2 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。  思路 动规 假设位置i(0≤i≤A.length)i(0≤i≤A.length)能够跳跃的最大长度为dp[i]。 对于数组A = [2,3,1,1,4]， 则有： i = 0, dp[0] = A[0] + 0 = 2 i = 1, if dp[i-1] ≥ i then dp[1] = max{A[1]+1,dp[0]} else dp[1] = 0 i = 2, if dp[i-1] ≥ i then dp[2] = max{A[2]+2,dp[1]} else dp[2] = 0 类推</description>
    </item>
    
    <item>
      <title>跳跃游戏</title>
      <link>/blog/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Sun, 09 Dec 2018 16:54:49 +0800</pubDate>
      
      <guid>/blog/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
      <description>问题描述 给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。  示例 2 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。  思路 动规 假设位置i(0≤i≤A.length)i(0≤i≤A.length)能够跳跃的最大长度为dp[i]。 对于数组A = [2,3,1,1,4]， 则有： i = 0, dp[0] = A[0] + 0 = 2 i = 1, if dp[i-1] ≥ i then dp[1] = max{A[1]+1,dp[0]} else dp[1] = 0 i = 2, if dp[i-1] ≥ i then dp[2] = max{A[2]+2,dp[1]} else dp[2] = 0 类推</description>
    </item>
    
    <item>
      <title>Z字形变换</title>
      <link>/blog/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Sun, 09 Dec 2018 16:52:40 +0800</pubDate>
      
      <guid>/blog/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      <description>问题描述 将字符串 &amp;quot;PAYPALISHIRING&amp;quot; 以Z字形排列成给定的行数：
P A H N A P L S I I G Y I R  之后从左往右，逐行读取字符：&amp;quot;PAHNAPLSIIGYIR&amp;quot;
实现一个将字符串进行指定行数变换的函数:
string convert(string s, int numRows);  示例 1 输入: s = &amp;quot;PAYPALISHIRING&amp;quot;, numRows = 3 输出: &amp;quot;PAHNAPLSIIGYIR&amp;quot;  示例 2 输入: s = &amp;quot;PAYPALISHIRING&amp;quot;, numRows = 4 输出: &amp;quot;PINALSIGYAHRPI&amp;quot; 解释: P I N A L S I G Y A H R P I  思路 方法一 按照与逐行读取 Z 字形图案相同的顺序访问字符串。 首先访问 行 0中的所有字符，接着访问 行 1，然后 行 2，依此类推&amp;hellip; 对于所有整数 k， * 行 0 中的字符位于索引k(2⋅numRows−2) 处; * 行 numRows−1 中的字符位于索引 k(2⋅numRows−2)+numRows−1 处; * 内部的行 i 中的字符位于索引k(2⋅numRows−2)+i 以及 (k+1)(2⋅numRows−2)−i 处;</description>
    </item>
    
    <item>
      <title>最小路径和</title>
      <link>/blog/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Sun, 09 Dec 2018 16:51:58 +0800</pubDate>
      
      <guid>/blog/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description> 问题描述 给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。  实现 func minPathSum(grid [][]int) int { m := len(grid) n := len(grid[0]) for i,rows := range grid { for j := range rows { if i == 0 { if j != 0 { grid[i][j] += grid[i][j - 1] } } else if j == 0 { grid[i][j] += grid[i-1][j] } else { if grid[i][j-1] &amp;lt; grid[i-1][j] { grid[i][j] += grid[i][j-1] } else { grid[i][j] += grid[i-1][j] } } } } return grid[m-1][n-1] }  </description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 09 Dec 2018 16:51:09 +0800</pubDate>
      
      <guid>/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description> 问题描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。
示例 1 输入: &amp;quot;babad&amp;quot; 输出: &amp;quot;bab&amp;quot; 注意: &amp;quot;aba&amp;quot;也是一个有效答案。  示例 2 输入: &amp;quot;cbbd&amp;quot; 输出: &amp;quot;bb&amp;quot;  思路 回文中心的两侧互为镜像。回文可以从它的中心展开，并且只有2n-1个这样的中心。
实现 func longestPalindrome(s string) string { lenS := len(s) if lenS &amp;lt;= 1 { return s } minStart, maxLen, i := 0, 1, 0 for i &amp;lt; lenS { if lenS-i &amp;lt;= maxLen/2 { break } j, k := i, i for k &amp;lt; lenS-1 &amp;amp;&amp;amp; s[k] == s[k+1] { k += 1 } i = k + 1 for k &amp;lt; lenS-1 &amp;amp;&amp;amp; j &amp;gt; 0 &amp;amp;&amp;amp; s[k+1] == s[j-1] { k, j = k+1, j-1 } if k-j+1 &amp;gt; maxLen { minStart, maxLen = j, k-j+1 } } return s[minStart : minStart+maxLen] }  </description>
    </item>
    
    <item>
      <title>字符串转整数 Atoi</title>
      <link>/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0-atoi/</link>
      <pubDate>Sun, 09 Dec 2018 16:50:05 +0800</pubDate>
      
      <guid>/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0-atoi/</guid>
      <description>问题描述 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31^, 2^31 ^− 1]。如果数值超过这个范围，qing返回 INT_MAX (2^31 ^− 1) 或 INT_MIN (−2^31^) 。
示例 1 输入: &amp;quot;42&amp;quot; 输出: 42  示例 2 输入: &amp;quot; -42&amp;quot; 输出: -42 解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  示例 3 输入: &amp;quot;4193 with words&amp;quot; 输出: 4193 解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。  示例 4 输入: &amp;quot;words and 987&amp;quot; 输出: 0 解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。  示例 5 输入: &amp;quot;-91283472332&amp;quot; 输出: -2147483648 解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。  思路 注意越界即可</description>
    </item>
    
    <item>
      <title>Pod处于containercreating状态</title>
      <link>/blog/pod%E5%A4%84%E4%BA%8Econtainercreating%E7%8A%B6%E6%80%81/</link>
      <pubDate>Sat, 08 Dec 2018 13:45:31 +0800</pubDate>
      
      <guid>/blog/pod%E5%A4%84%E4%BA%8Econtainercreating%E7%8A%B6%E6%80%81/</guid>
      <description>问题 用k8s创建完pod后，查了一下pods状态，发现都在containercreationg状态中
==&amp;gt; kubectl get pods
原因分析 用kubectl describe查看 pods的详情,发现 registry.access.redhat.com/rhel7/pod-infrastructure:latest 镜像报错
==&amp;gt; kubectl describe pod mysql
使用docker pull 拉取镜像，提示缺失rhsm 文件
==&amp;gt; docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
##解决方案
yum 安装 rhsm，发现 python-rhsm-certificates 已被 subscription-manager-rhsm-certificates 替换，无法yum 成功
==&amp;gt; yum install *rhsm*
使用 wget 获取python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm rpm包并安装 python-rhsm-certificates
==&amp;gt;wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm
==&amp;gt;rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem | tee /etc/rhsm/ca/redhat-uep.pem
再次使用使用docker pull 拉取镜像
==&amp;gt; docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
成功 pods 已成功 在Running 状态中
==&amp;gt; kubectl get pods</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 08 Dec 2018 12:55:29 +0800</pubDate>
      
      <guid>/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description> 问题描述 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。
示例 1 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot;  示例 2 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。  说明 所有输入只包含小写字母 a-z 。
思路 按需匹配即可，遇到不符即可立即返回
实现 func longestCommonPrefix(strs []string) string { short := shortest(strs) for i, r := range short { for j := 0; j &amp;lt; len(strs); j++ { if strs[j][i] != byte(r) { return strs[j][:i] } } } return short } func shortest(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } res := strs[0] for _, s := range strs { if len(res) &amp;gt; len(s) { res = s } } return res }  </description>
    </item>
    
    <item>
      <title>从排序数组中删除重复项</title>
      <link>/blog/%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sat, 08 Dec 2018 12:53:52 +0800</pubDate>
      
      <guid>/blog/%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>问题描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。  示例 2 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。  实现 C++ 版本 使用了 stl 库中的方法 unique 和 erase，最后使用 size 方法返回长度
unique 的是实现原理是，比较两个相邻的元素，如果元素相同则将它移到最后去，并且最后返回一个非冗余元素的迭代器
然后用 erase 删除冗余的元素。
static bool init = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return true; }(); class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { nums.</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机-II</title>
      <link>/blog/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</guid>
      <description> 问题描述 给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  示例 2 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。  示例 3 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。  实现 Go 版本 func maxProfit(prices []int) int { var max int for i := 1; i &amp;lt; len(prices); i++ { if prices[i] &amp;gt; prices[i-1] { max += prices[i] - prices[i-1] } } return max }  Go 测试 </description>
    </item>
    
    <item>
      <title>位1的个数</title>
      <link>/blog/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>问题描述 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
示例 1 输入: 11 输出: 3 解释: 整数 11 的二进制表示为 00000000000000000000000000001011  示例 2 输入: 128 输出: 1 解释: 整数 128 的二进制表示为 00000000000000000000000010000000  解法 bits.OnesCount 注意到 Go 的 bits 包提供了 OnesCount 方法，即返回参数的二进制表示中 1 的个数
func hanmingWeight(n uint) int { return bits.OnesCount(n) }  普通计数 按位与操作(&amp;amp;)，按二进制位进行“与”运算，运算规则： 0 &amp;amp; 0 = 0; 0 &amp;amp; 1 = 0; 1 &amp;amp; 0 = 0; 1 &amp;amp; 1 = 1;</description>
    </item>
    
    <item>
      <title>分发饼干</title>
      <link>/blog/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</guid>
      <description> 问题描述 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g~i ，~这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s~j ~。如果 s~j~ &amp;gt;= g~i ~，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
注意：
你可以假设胃口值为正。 一个小朋友最多只能拥有一块饼干。
示例 1 输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。  示例 2 输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.  实现 import ( &amp;quot;sort&amp;quot; ) func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) var i, j, res int for i &amp;lt; len(g) &amp;amp;&amp;amp; j &amp;lt; len(s) { if g[i] &amp;lt;= s[j] { res++ i++ } j++ } return res }  </description>
    </item>
    
    <item>
      <title>删除链表中的节点</title>
      <link>/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>问题描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 &amp;ndash; head = [4,5,1,9]，它可以表示为:
 4 -&amp;gt; 5 -&amp;gt; 1 -&amp;gt; 9  示例 1 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.  示例 2 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.  思路1 &amp;quot;Dummy node&amp;quot; 节点 能大大简化链接列表问题。但是该题是一个单向链表
故不能使用删除目标的前驱节点的后继改为目标节点的后继，思考一下，可以把要删除的节点直接赋值后继节点值然后直接删除其后继节点，可以达到相同的目的。
例子：ABCDE，删除C，我们就先用D占C的位置，变成ABDDE，然后把后面那个D删除，就可以得到ABDE
思路2 直接把给定的节点B替换成其后的节点C
实现 Go 版本1 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>打家劫舍</title>
      <link>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</guid>
      <description>问题描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
示例 1 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。  示例 2 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。  思路 先分析，原子问题就是这个房间是否要偷。 两种情况，（设收益f（n）为前n个房间的最高收益） 1.</description>
    </item>
    
    <item>
      <title>旋转数组</title>
      <link>/blog/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</guid>
      <description> 问题描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
示例 1 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4]  示例 2 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100]  思路 对应的两数互换即可
实现 Go 版本 func rotate(nums []int, k int) { if len(nums) &amp;lt;= 1 || k &amp;lt;= 0 || k%len(nums) == 0 { return } length := len(nums) k = k % length tmp := nums[0] index := 0 start := 0 for i := 0; i &amp;lt; length; i++ { index = (index + k) % length tmp, nums[index] = nums[index], tmp if start == index { start += 1 index = start tmp = nums[start] } } return }  </description>
    </item>
    
    <item>
      <title>求众数</title>
      <link>/blog/%E6%B1%82%E4%BC%97%E6%95%B0/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E6%B1%82%E4%BC%97%E6%95%B0/</guid>
      <description> 问题描述 给定一个大小为 *n *的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在众数。
示例 1 输入: [3,2,3] 输出: 3  示例 2 输入: [2,2,1,1,1,2,2] 输出: 2  实现 Go 版本 func majorityElement(nums []int) int { standard := len(nums)/2 record := make(map[int]int) for i := 0; i &amp;lt; len(nums); i++{ record[nums[i]]++ if record[nums[i]] &amp;gt; standard{ return nums[i] } } return 0 }  </description>
    </item>
    
    <item>
      <title>长度最小的子数组</title>
      <link>/blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 08 Dec 2018 12:43:36 +0800</pubDate>
      
      <guid>/blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description> 问题描述 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。
示例  输入: s = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。  思路 使用一个可以扩张收缩的窗口来实现 窗口使用两个索引 l 和 r ，相当与一个滑块，滑块包含 nums[l&amp;hellip;r] 这些元素，如果 nums[l..r] 的和小于目标值 s，那么 r 向后移一位，再次比较，直到大于目标值 s 之后，l 向前移动一位，缩小数组的长度。 遍历直到 right 到达数组末端。
实现 Go 版本 func minSubArrayLen(s int, nums []int) int { n := len(nums) result := n + 1 sum := 0 l, r := 0, -1 for l &amp;lt; n { if r+1 &amp;lt; n &amp;amp;&amp;amp; sum &amp;lt; s { r++ sum += nums[r] } else { sum -= nums[l] l++ } if sum &amp;gt;= s { if r-l+1 &amp;lt; result { result = r - l + 1 } } } if result == n+1 { result = 0 } return result }  </description>
    </item>
    
    <item>
      <title>到最近的人的最大距离</title>
      <link>/blog/%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sat, 08 Dec 2018 12:41:53 +0800</pubDate>
      
      <guid>/blog/%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</guid>
      <description> 问题描述 在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。
至少有一个空座位，且至少有一人坐在座位上。
亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。
返回他到离他最近的人的最大距离。
示例 1 输入：[1,0,0,0,1,0,1] 输出：2 解释： 如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。 如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。 因此，他到离他最近的人的最大距离是 2  示例 2 输入：[1,0,0,0] 输出：3 解释： 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。 这是可能的最大距离，所以答案是 3 。  思路 考虑三种情况，根据 0 个数来计算，最左边或最右边有最多的连续 0 ，那么结果就是相应 0 的个数，如果连续 0 在中间，考虑到连续 0 数量的奇偶，加上 1 再整除 2 。
实现 Go 版本 func maxDistToClosest(seats []int) int { maxDist, cnt := 0, 0 for i := 0; i &amp;lt; len(seats) &amp;amp;&amp;amp; seats[i] == 0; i++ { cnt++ } maxDist = cnt for i := 0; i &amp;lt; len(seats); i++ { if seats[i] == 0 { cnt++ } else { if maxDist &amp;lt; (cnt+1)/2 { maxDist = (cnt + 1) / 2 } cnt = 0 } } if maxDist &amp;lt; cnt { maxDist = cnt } return maxDist }  </description>
    </item>
    
    <item>
      <title>有效的括号</title>
      <link>/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sat, 08 Dec 2018 12:41:16 +0800</pubDate>
      
      <guid>/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>问题描述 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  注意空字符串可被认为是有效字符串。
示例 1 输入: &amp;quot;()&amp;quot; 输出: true  示例 2 输入: &amp;quot;()[]{}&amp;quot; 输出: true  示例 3 输入: &amp;quot;(]&amp;quot; 输出: false  示例 4 输入: &amp;quot;([)]&amp;quot; 输出: false  示例 5 输入: &amp;quot;{[]}&amp;quot; 输出: true  思路 初始化栈 stack 一次处理表达式的每个括号，遍历给定的 string 如果遇到左括号，推到栈上稍后处理它， 遇到一个右括号，检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，则从栈中弹出并继续处理。 否则返回 false 最后检查栈中是否有元素，可以判断是否无效
实现 栈方法 func isValid(s string) bool { stack := make([]byte, 0) config := map[byte]byte{ &#39;)&#39;: &#39;(&#39;, &#39;}&#39;: &#39;{&#39;, &#39;]&#39;: &#39;[&#39;, } for i := 0; i &amp;lt; len(s); i++ { b := s[i] if config[b] !</description>
    </item>
    
    <item>
      <title>两数之和</title>
      <link>/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 08 Dec 2018 12:40:07 +0800</pubDate>
      
      <guid>/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description> 问题描述 给定一个整数数列，找出其中和为特定值的那两个数。
你可以假设每个输入都只会有一种答案，同样的元素不能被重用。
示例 1 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  思路 1.遍历每个元素 x，并查找是否存在一个值与 target−x相等的目标元素。 2.在进行迭代并将元素插入到表中的同时，检查表中是否已经存在当前元素所对应的目标元素。如果它存在立即将其返回
实现 暴力法 哈希法 func twoSum(nums []int, target int) []int { m := make(map[int]int) for i := 0; i &amp;lt; len(nums); i++ { another := target - nums[i] if _, ok := m[another]; ok { return []int{m[another], i} } m[nums[i]] = i } return nil }  </description>
    </item>
    
    <item>
      <title>Ssh连接</title>
      <link>/blog/ssh%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Fri, 07 Dec 2018 12:27:27 +0800</pubDate>
      
      <guid>/blog/ssh%E8%BF%9E%E6%8E%A5/</guid>
      <description> 问题 ssh远程连接服务器
提示：Permission denied (publickey,gssapi-keyex,gssapi-with-mic)
原因分析 参数 PasswordAuthentication 的默认值为 yes，SSH服务将其值置为 no 以禁用密码验证登录，导致此类故障。需要修改 PasswordAuthentication 配置解决此问题。
解决方法 ###在服务端执行
 执行命令 vi /etc/ssh/sshd_config，按下 i 编辑SSH服务配置文件，将参数 PasswordAuthentication 设置为 yes，或者在 PasswordAuthentication 参数前添加井号（#），按下 Esc 退出编辑模式，并输入 :wq 保存退出。  
 执行命令 service ssh restart 重启SSH服务。   说明：如果您使用CentOS 7及以上，执行命令 systemctl restart sshd 重启SSH服务。
 在使用端执行  记得删除之前连接时添加的known_host记录   说明：通常在 &amp;lt;用户名&amp;gt;/.ssh/ 目录下
 </description>
    </item>
    
    <item>
      <title>设计链表</title>
      <link>/blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 07 Dec 2018 11:21:45 +0800</pubDate>
      
      <guid>/blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>问题描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
 get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。  示例 MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3 linkedList.get(1); //返回3  提示  所有值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。  思路 实现很简单，ac有很多坑</description>
    </item>
    
    <item>
      <title>回文数</title>
      <link>/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>问题描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1 输入: 121 输出: true  示例 2 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。  示例 3 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。  进阶:
你能不将整数转为字符串来解决这个问题吗？
思路 将数字一半反转，然后将反转后的数字与原始数字另一半进行比较，如果它们是相同的，那么这个数字就是回文。  例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较即可。 负数不是回文。
实现 func isPalindrome(x int) bool { if x &amp;lt; 0 { return false } if (x &amp;lt; 10) { return true } p, k := 0, x for k!</description>
    </item>
    
    <item>
      <title>Hugo&#43;Github搭建个人博客</title>
      <link>/blog/hugo-github-blog/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/hugo-github-blog/</guid>
      <description>前言介绍  Hugo是什么?   Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态页面生成引擎。
 官网https://gohugo.io/
 静态页面生成引擎又是什么?   静态页面生成引擎从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。
  那么我采用Hugo来搭建博客优点有哪些?
 访问快速.因为不需要每次访问生成页面当然，一旦网站有任何更改，静态网站生成器需要重新生成所有的与更改相关的页面。然后由于Hugo是用Go语言编写的在生成速度这方面做的非常好.5000篇文章的博客生成时间只需要6秒钟.对比其他的静态页面生成引擎动不动几分钟的时间优势非常明显 采用静态页面搭建博客,维护起来非常简单.事实上根本不需要什么维护，完全不用考虑复杂的运行时间，依赖和数据库的问题。再有也不用担心安全性的问题，没有数据库，网站注入什么的也无从下手 无依赖.低消耗资源. 专注于写作.我认为对于个人博客来说，应该将时间花在内容上而不是各种折腾网站。Hugo会将Markdown格式的内容和设置好模版一起，生成漂亮干净的页面。你只需要把Markdown文件放在content文件夹下面.一切水到渠成  听起来很棒的样子那搭建起来会不会非常复杂?
  不会.跟着教程走下来.只需要十分钟.
开始 需求 1.Hugo工具 2.GitHub个人账号 3.Git工具  安装 如果说速度快是Hugo的第一大优点，那么安装简单应该就是Hugo的第二大优点。对于Mac用户，没有brew的话先安装brew，在命令行里敲：
$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  然后再敲一行安装Hugo:
$ brew new Hugo  当然你也可以在这里直接下载对应系统的binary文件，解压就行了。
生成 site 目录 hugo new site blog cd blog git init #Congratulations! Your new Hugo site is created in /Users/steven/MyProjects/Demo/blog.</description>
    </item>
    
    <item>
      <title>HyperLogLog</title>
      <link>/blog/hyperloglog%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/hyperloglog%E7%AE%97%E6%B3%95/</guid>
      <description>更好的阅读参见我的语雀
基数计数基本概念 基数计数(cardinality counting)通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。 要实现基数计数，最简单的做法是记录集合中所有不重复的元素集合，当新来一个元素，若中不包含元素​，则将加入，否则不加入，计数值就是​的元素数量。这种做法存在两个问题：
 当统计的数据量变大时，相应的存储内存也会线性增长 当集合变大，判断其是否包含新加入元素​的成本变大  概率算法 实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:
 Linear Counting(LC)：早期的基数估计算法，LC在空间复杂度方面并不算优秀，实际上LC的空间复杂度与简单bitmap方法是一样的（但是有个常数项级别的降低），都是O(N​max​​)； LogLog Counting(LLC)：LogLog Counting相比于LC更加节省内存，空间复杂度只有O(log​2​​(log​2​​(N​max​​))) HyperLogLog Counting(HLL)：HyperLogLog Counting是基于LLC的优化和改进，在同样空间复杂度情况下，能够比LLC的基数估计误差更小。  HLL 直观演示 HLLDEMO
HLL的实际步骤  通过hash函数计算输入值对应的比特串 比特串的低 位对应的数字用来找到数组S中对应的位置 i t+1位开始找到第一个1出现的位置 k，将 k 记入数组位置 基于数组S记录的所有数据的统计值，计算整体的基数值，计算公式可以简单表示为：  HLL是LLC的误差改进，实际是基于LLC。
算法来源（N次伯努利过程） 下面非正式的从直观角度描述LLC算法的思想来源。
设a为待估集合（哈希后）中的一个元素，由上面对H的定义可知，a可以看做一个长度固定的比特串（也就是a的二进制表示），设H哈希后的结果长度为L比特，我们将这L个比特位从左到右分别编号为1、2、…、L：
又因为a是从服从均与分布的样本空间中随机抽取的一个样本，因此a每个比特位服从如下分布且相互独立。
 通俗说就是a的每个比特位为0和1的概率各为0.5，且相互之间是独立的。 设 ρ(a)为a的比特串中第一个“1”出现的位置，显然1≤ρ(a)≤L，这里我们忽略比特串全为0的情况（概率为）。如果我们遍历集合中所有元素的比特串，取为所有ρ(a)的最大值。 此时我们可以将作为基数的一个粗糙估计，即：  解释 注意如下事实：
由于比特串每个比特都独立且服从0-1分布，因此从左到右扫描上述某个比特串寻找第一个“1”的过程从统计学角度看是一个伯努利过程，例如，可以等价看作不断投掷一个硬币（每次投掷正反面概率皆为0.5），直到得到一个正面的过程。在一次这样的过程中，投掷一次就得到正面的概率为1/2，投掷两次得到正面的概率是，…，投掷k次才得到第一个正面的概率为。
现在考虑如下两个问题：
1、进行n次伯努利过程，所有投掷次数都不大于k的概率是多少？
2、进行n次伯努利过程，至少有一次投掷次数等于k的概率是多少？
首先看第一个问题，在一次伯努利过程中，投掷次数大于k的概率为，即连续掷出k个反面的概率。因此，在一次过程中投掷次数不大于k的概率为。因此，n次伯努利过程投掷次数均不大于k的概率为：
 显然第二个问题的答案是：
 从以上分析可以看出，当时，Pn(X≥k)的概率几乎为0，同时，当时，Pn(X≤k)的概率也几乎为0。用自然语言概括上述结论就是：当伯努利过程次数远远小于时，至少有一次过程投掷次数等于k的概率几乎为0；当伯努利过程次数远远大于时，没有一次过程投掷次数大于k的概率也几乎为0。
如果将上面描述做一个对应：一次伯努利过程对应一个元素的比特串，反面对应0，正面对应1，投掷次数k对应第一个“1”出现的位置，我们就得到了下面结论：
设一个集合的基数为n，为所有元素中首个“1”的位置最大的那个元素的“1”的位置，如果n远远小于，则我们得到为当前值的概率几乎为0（它应该更小），同样的，如果n远远大于，则我们得到为当前值的概率也几乎为0（它应该更大），因此可以作为基数n的一个粗糙估计。
以上结论可以总结为：进行了n次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数kk，那么可以用n次实验中最大的抛掷次数来预估实验组数量n： 
回到基数统计的问题，我们需要统计一组数据中不重复元素的个数，集合中每个元素的经过hash函数后可以表示成0和1构成的二进制数串，一个二进制串可以类比为一次抛硬币实验，1是抛到正面，0是反面。二进制串中从低位开始第一个1出现的位置可以理解为抛硬币试验中第一次出现正面的抛掷次数k，那么基于上面的结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样可以可以通过第一个1出现位置的最大值​来预估总共有多少个不同的数字（整体基数）。
LogLogCounting 均匀随机化 与LC一样，在使用LLC之前需要选取一个哈希函数H应用于所有元素，然后对哈希值进行基数估计。H必须满足如下条件（定性的）：
1、H的结果具有很好的均匀性，也就是说无论原始集合元素的值分布如何，其哈希结果的值几乎服从均匀分布（完全服从均匀分布是不可能的，D. Knuth已经证明不可能通过一个哈希函数将一组不服从均匀分布的数据映射为绝对均匀分布，但是很多哈希函数可以生成几乎服从均匀分布的结果，这里我们忽略这种理论上的差异，认为哈希结果就是服从均匀分布）。
2、H的碰撞几乎可以忽略不计。也就是说我们认为对于不同的原始值，其哈希结果相同的概率非常小以至于可以忽略不计。</description>
    </item>
    
    <item>
      <title>Create A Service By Gin-Gorm</title>
      <link>/blog/gin-grom%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/gin-grom%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1/</guid>
      <description>原文链接：https://medium.com/@cgrant/developing-a-simple-crud-api-with-go-gin-and-gorm-df87d98e6ed1 翻译：devabel 整理：abser
入门 这个例子假设你已经安装并运行go语言的环境。如果您还没有安装，请转到http://cgrant.io/tutorials/go/getting-started-with-go/获取快速入门。
Gin Web框架 由于我们将通过HTTP提供我们的API，因此我们需要一个Web框架来处理路由并提供请求。有许多框架可用，具有不同的功能和性能指标。在这个例子中，我们将使用Gin框架https://github.com/gin-gonic/gin 。由于速度和简单性，Gin是API开发的一个很好的框架。
首先，让我们在$ GOPATH / src / simple-api中为我们的服务创建一个新文件夹，然后添加一个main.go文件，如下所示
package main import “fmt” func main() { fmt.Println(“Hello World”) }  在我们继续学习前，让我们测试一下，确保一切正常运行。
$ go run main.go Hello World  程序运行正常。现在让我们使用Gin框架将它变成一个Web应用程序。
package main import “github.com/gin-gonic/gin” func main() { r := gin.Default() r.GET(“/”, func(c *gin.Context) { c.String(200, “Hello World”) }) r.Run() }  保存并运行它
$ go run main.go [GIN-debug] [WARNING] Running in “debug” mode. Switch to “release” mode in production.</description>
    </item>
    
    <item>
      <title>Learn Gorm</title>
      <link>/blog/gorm-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/gorm-%E5%85%A5%E9%97%A8/</guid>
      <description>ORM（Object Relation Mapping），对象关系映射，实际上就是对数据库的操作进行封装，对上层开发人员屏蔽数据操作的细节，开发人员看到的就是一个个对象，大大简化了开发工作，提高了生产效率
好了，下面我以这个点赞评论系统为例，介绍一下 gorm 的简单用法，以下使用的完整代码：https://github.com/hatlonely/...
#gorm 用法介绍 ##库安装 go get -u github.com/jinzhu/gorm ##数据库连接
import ( &amp;quot;github.com/jinzhu/gorm&amp;quot; _ &amp;quot;github.com/jinzhu/gorm/dialects/mysql&amp;quot; ） var db *gorm.DB func init() { var err error db, err = gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;/&amp;lt;database&amp;gt;?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;quot;) if err != nil { panic(err) } }  连接比较简单，直接调用 gorm.Open 传入数据库地址即可
github.com/jinzhu/gorm/dialects/mysql 是 golang 的 mysql 驱动，实际上就是 github.com/go-sql-driver/mysql 作者这里为了好记，重新弄了个名字
这里我用的 mysql，实际上支持基本上所有主流的关系数据库，连接方式上略有不同
db.DB().SetMaxIdleConns(10) db.DB().SetMaxOpenConns(100) 还可以使用 db.DB() 对象设置连接池信息
###表定义 先来定义一个点赞表，这里面一条记录表示某个用户在某个时刻对某篇文章点了一个赞，用 ip + ua 来标识用户，title 标识文章标题
type Like struct { ID int `gorm:&amp;quot;primary_key&amp;quot;` Ip string `gorm:&amp;quot;type:varchar(20);not null;index:ip_idx&amp;quot;` Ua string `gorm:&amp;quot;type:varchar(256);not null;&amp;quot;` Title string `gorm:&amp;quot;type:varchar(128);not null;index:title_idx&amp;quot;` Hash uint64 `gorm:&amp;quot;unique_index:hash_idx;&amp;quot;` CreatedAt time.</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>/blog/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>/blog/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/goisforlovers/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>/blog/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/hugoisforlovers/</guid>
      <description>&lt;h2 id=&#34;step-1-install-hugo&#34;&gt;Step 1. Install Hugo&lt;/h2&gt;

&lt;p&gt;Go to &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;hugo releases&lt;/a&gt; and download the
appropriate version for your os and architecture.&lt;/p&gt;

&lt;p&gt;Save it somewhere specific as we will be using it in the next step.&lt;/p&gt;

&lt;p&gt;More complete instructions are available at &lt;a href=&#34;/overview/installing/&#34;&gt;installing hugo&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>/blog/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/migrate-from-jekyll/</guid>
      <description>&lt;h2 id=&#34;move-static-content-to-static&#34;&gt;Move static content to &lt;code&gt;static&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Jekyll has a rule that any directory not starting with &lt;code&gt;_&lt;/code&gt; will be copied as-is to the &lt;code&gt;_site&lt;/code&gt; output. Hugo keeps all static content under &lt;code&gt;static&lt;/code&gt;. You should therefore move it all there.
With Jekyll, something that looked like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;▾ &amp;lt;root&amp;gt;/
    ▾ images/
        logo.png
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>